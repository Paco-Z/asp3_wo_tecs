
		TOPPERS/ASP3カーネル without TECS
		ユーザーズマニュアル

		対応バージョン: Release 3.2.0
		最終更新: 2017年7月4日

このドキュメントは，TOPPERS/ASP3カーネル without TECSを使用するため
に必要な事項を説明するものである．

このドキュメントでは，通常のTOPPERS/ASP3カーネルとは異なる点について説
明する．TOPPERS/ASP3カーネル without TECS では，システムサービスを
TOPPERS/ASPカーネルと同様にC言語に記述する点が異なる．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2017 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: user.txt 752 2016-05-14 15:06:22Z ertl-hiro $
----------------------------------------------------------------------

○目次

４．ディレクトリ構成・ファイル構成
	4.2 ターゲット非依存部のファイル構成
８．システムサービス
	8.1 システムログ機能
		8.1.1 システムログ機能の位置付け
		8.1.2 ログバッファへの記録と低レベル出力
		8.1.3 ログ情報の種別
		8.1.4 ログ情報の重要度
		8.1.5 ログ情報のデータ構造
		8.1.6 システムログ機能のサービスコール
		8.1.7 システムログ機能のためのライブラリ関数とマクロ
		8.1.8 システムログ機能のその他のサービス
	8.2 シリアルインタフェースドライバ
		8.2.1 シリアルインタフェースドライバのサービスコール
		8.2.2 シリアルインタフェースドライバのその他のサービス
	8.3 システムログタスク
		8.3.1 システムログタスクのサービスコール
		8.3.2 システムログタスクのその他のサービス
	8.4 実行時間分布集計サービス
	8.5 カーネル起動メッセージの出力
１０．テストプログラム
	10.1 テストプログラム用サービス
	10.2 カーネルの整合性検査
	10.3 機能テストプログラム
	10.4 システム時刻管理機能テストプログラム
	10.5 性能評価プログラム
１３．リファレンス
	13.3 バージョン履歴

４．ディレクトリ構成・ファイル構成

4.2 ターゲット非依存部のファイル構成

ターゲット非依存部（テストプログラムと拡張パッケージは除く）の各ファイ
ルの概要は次の通り．

  syssvc/
	banner.h		カーネル起動メッセージの出力のための定義
	banner.c		カーネル起動メッセージの出力
	banner.cfg		カーネル起動メッセージの出力のコンフィギュレー
					ションファイル
	histogram.h		実行時間分布集計サービスを使用するための定義
	histogram.c		実行時間分布集計サービス
	logtask.h		システムログタスクを使用するための定義
	logtask.c		システムログタスク
	logtask.cfg		システムログタスクのコンフィギュレーションファイル
	serial.h		シリアルインタフェースドライバを使用するための定義
	serial.c		シリアルインタフェースドライバ
	serial.cfg		シリアルドライバのコンフィギュレーションファイル
	syslog.h		システムログ機能を使用するための定義
	syslog.c		システムログ機能
	syslog.cfg		システムログ機能のコンフィギュレーションファイル
	test_svc.h		テストプログラム用サービスを使用するための定義
	test_svc.c		テストプログラム用サービス

８．システムサービス

8.1 システムログ機能

システムログ機能は，カーネル内で発生した異常事象やトレースログ，システ
ムサービスやアプリケーションで発生した異常事象やトレースログを，ログ情
報として記録するための機能である．また，記録したログ情報を取り出す機能
も持つ．

システムログ機能は，システムコンフィギュレーションファイルでsyslog.cfg
をインクルードすることで，システムに組み込むことができる．システムログ
出力を行うソースファイルでは，t_syslog.hをインクルードする．また，シス
テムログ機能のその他のサービスコールを呼び出すソースファイルでは，
syslog.hをインクルードする．

8.1.1 システムログ機能の位置付け

システムログ機能は，カーネル内からも呼び出すことができるため，カーネル
より下の階層のモジュールと位置付けることができる．この意味では，他のシ
ステムサービスとは位置付けが異なる．

一方，ログ情報をシステム外部に出力するためには，シリアルインタフェース
ドライバなど，カーネル上で動作するシステムサービスを用いる必要がある．
そこで，ログ情報をシステム外部に出力するためのサービス（これを，システ
ムログタスクと呼ぶ）は，システムログ機能とは分離して実装することとし，
システムログ機能はログ情報の記録・取出しのための機能に絞っている．

以上のように，システムログ機能はカーネルより下の階層のモジュールである
が，システムログ機能の中でログ時刻を取り出すために，カーネルの機能を必
要とする．実装上は，カーネルの内部変数を直接参照している．そのため，カー
ネルの実行開始前や終了後は，ログ時刻は正しく記録されない．

8.1.2 ログバッファへの記録と低レベル出力

上述したように，ログ情報をシステムの外部に出力するためには，カーネル上
で動作するシステムサービスを用いる必要があるため，カーネルの動作を継続
できないような重大な異常事象が起こった場合には，ログ情報を出力できなく
なる．また，これらのシステムサービス自身をデバッグする場合にも，ログ情
報の出力ができない．

そこで，カーネル上で動作するシステムサービスが使えない場合にでもログ情
報を出力するために，低レベル出力機能を用意する．低レベル出力機能は，ター
ゲット依存に用意する低レベルの文字出力関数を用いてログ情報を出力する機
能である．低レベルの文字出力関数は，ターゲット依存部で用意することとし
ているが，最終製品に組み込まれる場合などでは，文字を出力する方法がない
状況も考えられる．そのような場合，低レベルの文字出力関数に送られた文字
は，メモリ上に残しておくか，捨ててしまうしかない．

ログ情報を，ログバッファへ記録するか低レベル出力機能を用いて出力するか
の設定は，システムログ機能のサービスコール（syslog_msk_log）によって行
うことができる．syslog_msk_logの使い方については後述する．デフォルトで
は（システムログタスクを動作させず，syslog_msk_logも呼び出さない場合），
すべてのログ情報を低レベル出力機能を用いて出力し，ログバッファには記録
しない．

低レベル出力機能を用いると，ログメッセージの作成処理（printf相当の処理）
と低レベルの文字出力処理をカーネル内で行うために，カーネルの応答性が悪
くなることに注意しなければならない．特に，低レベルの文字出力処理はデバ
イスをポーリングする形で実装するのが通常で，その場合には，カーネルの応
答性は実用的と言えない程に悪くなる．

8.1.3 ログ情報の種別

システムログ機能は，ログ情報に以下の種別を設けている．

		LOG_TYPE_COMMENT	コメント
		LOG_TYPE_ASSERT		アサーションの失敗
		LOG_TYPE_INH		割込みハンドラ
		LOG_TYPE_ISR		割込みサービスルーチン
		LOG_TYPE_CYC		周期ハンドラ
		LOG_TYPE_ALM		アラームハンドラ
		LOG_TYPE_OVR		オーバランハンドラ
		LOG_TYPE_EXC		CPU例外ハンドラ
		LOG_TYPE_TEX		タスク例外処理ルーチン
		LOG_TYPE_TSKSTAT	タスク状態変化
		LOG_TYPE_DSP		ディスパッチャ
		LOG_TYPE_SVC		サービスコール

ログ情報の種別の中で，LOG_TYPE_COMMENTとLOG_TYPE_ASSERT以外は，カーネル
のトレースログに用いるためのものであるが，使用するかどうかはターゲット
依存部に任されている．

8.1.4 ログ情報の重要度

システムログ機能は，ログ情報を出力する際に指定する重要度に基づいて，実
際に出力するログ情報を動的に設定することができる．これは，UNIXのシステ
ムログ機能をまねたもので，ログの重要度の種類や指定方法もUNIXのAPIを参考
にしている．また，低レベル出力機能を用いて出力するログ情報も，重要度に
基づいて動的に設定することができる．

具体的には，ログの重要度として次の8段階を用意している．

		LOG_EMERG		カーネルの動作を継続できないエラー
		LOG_ALERT
		LOG_CRIT
		LOG_ERROR		重要性の低いシステムエラー
		LOG_WARNING		警告メッセージ．システムは安全に継続動作できる
		LOG_NOTICE
		LOG_INFO
		LOG_DEBUG		デバッグのためのメッセージ

どの重要度のログ情報をログバッファに記録するかと，どの重要度のログ情報
を低レベル出力機能を用いて出力するかは，システムログ機能のサービスコー
ル（syslog_msk_log）によって設定することができる．

8.1.5 ログ情報のデータ構造

ログ情報を格納するためのデータ型として，SYSLOG構造体を用意している．
SYSLOG構造体には，ログ情報の種別（logtypeフィールド），ログ時刻
（logtimフィールド）と6つのログパラメータ（logparフィールド）が含まれる．

ログ時刻のデータ型（LOGTIM）とログパラメータのデータ型（LOGPAR）は，標
準ではそれぞれHRTCNT（高分解能タイマのカウント値のデータ型）とintptr_t
に定義されているが，ターゲット依存部（target_stddef.hまたはそこからイン
クルードされるファイル）により変更することができる．

SYSLOG構造体に格納されたログ情報を出力する場合，ログ時刻（logtimフィー
ルド）は出力関数（syslog_wri_log）によって書き込まれるため，出力関数を
呼ぶ側で書き込む必要はない．

8.1.6 システムログ機能のサービスコール

システムログ機能の提供するサービスコールは次の通りである．これらのサー
ビスコールを呼び出すソースファイルでは，syslog.hをインクルードする必要
がある．

(1) ER syslog_wri_log(uint_t prio, const SYSLOG *p_syslog)

システムログ機能に，p_syslogで指定されるログ情報を，prioで指定される重
要度で出力する（ログバッファへ記録するか低レベル出力機能を用いて出力す
る）．

プロトタイプ宣言において，*p_syslogにconst指定がされているが，実際には，
この関数の中で，*p_syslogのlogtimフィールドにシステム時刻を書き込んでい
る．

(2) ER_UINT syslog_rea_log(SYSLOG *p_syslog)

ログバッファからログ情報を1つ取り出す．ログバッファが空の時はE_OBJ，そ
うでない場合は，ログバッファのオーバフローにより失われたログ情報の数
（ログ情報が失われていない場合は0）を返す．システムログタスクが用いるこ
とを想定している．

(3) ER syslog_msk_log(uint_t logmask, uint_t lowmask)

ログバッファに記録すべきログ情報の重要度の示すビットマップ（logmask）と，
低レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマップ
（lowmask）を設定する．ビットマップを作るためのマクロとして，LOG_MASKと
LOG_UPTOを用意している．

(4) ER syslog_ref_log(T_SYSLOG_RLOG *pk_rlog)

システムログ機能の状態を参照する．具体的には，ログバッファに記録されて
いるログ情報の数（T_SYSLOG_RLOG構造体のcountフィールド），ログバッファ
のオーバフローにより失われたログ情報の数（lostフィールド），ログバッファ
に記録すべきログ情報の重要度の示すビットマップ（logmaskフィールド），低
レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマップ
（lowmaskフィールド）を参照することができる．

(5) ER syslog_fls_log(void)

ログバッファに記録されているログ情報をすべて取り出し，低レベル出力機能
を用いて出力する．

8.1.7 システムログ機能のためのライブラリ関数とマクロ

システムログ出力のためのライブラリ関数とマクロは次の通りである．これら
だけを呼び出すソースファイルでは，t_syslog.hをインクルードすればよい．

(1) void _syslog_n(uint_t prio, uint_t type, LOGPAR arg1, ..., LOGPAR argn)
    ※ nは0～6のいずれか．

ログ種別がtype，ログパラメータがarg1～argnのログ情報を，重要度prioで出
力するための関数．

(2) void syslog_n(uint_t prio, const char *format, arg1, ..., argn)
    ※ nは0～5のいずれか．

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するためのマクロ．

formatはメッセージのフォーマット記述（printfのフォーマット記述と類似），
arg1～argnはフォーマット記述中で参照される値である．arg1～argnは，この
マクロ中でLOGPAR型にキャストされるため，LOGPAR型に型変換できる任意の型
を渡すことができ，型チェックはされない．formatおよびarg1～argnには，次
の制限がある．

・formatのフォーマット記述は，定数文字列を渡すことを想定しており，この
マクロ処理を終えた後も変化してはならない．

・format中に使えるフォーマット指定は次の通り．

	%d		引数をint_t型とみなし，10進数で表示
	%u		引数をuint_t型とみなし，10進数で表示
	%x		引数をuint_t型とみなし，16進数（英文字は小文字）で表示
	%X		引数をuint_t型とみなし，16進数（英文字は大文字）で表示
	%p		引数をポインタとみなし，16進数（英文字は小文字）で表示
	%c		引数を文字コードとみなし，文字を表示
	%s		引数を文字列を示すポインタとみなし，文字列を表示
	%%		'%'を表示（引数は取らない）

%d, %u, %x, %Xにおいては，'%'の直後に表示桁数を指定する10進数値を記述す
ることができる．その場合，表示すべき文字列が指定した桁数に満たない場合
には，指定した桁数内に右詰めで表示する．10進数値が'0'で始まる場合には，
その間に'0'を埋める．

また，サイズ指定を付与した次のフォーマット指定も使うことができる．

	%ld		引数をlong_t型とみなし，10進数で表示
	%lu		引数をulong_t型とみなし，10進数で表示
	%lx		引数をulong_t型とみなし，16進数（英文字は小文字）で表示
	%lX		引数をulong_t型とみなし，16進数（英文字は大文字）で表示

	%td		引数をint32_t型とみなし，10進数で表示
	%tu		引数をuint32_t型とみなし，10進数で表示
	%tx		引数をuint32_t型とみなし，16進数（英文字は小文字）で表示
	%tX		引数をuint32_t型とみなし，16進数（英文字は大文字）で表示

	%Tu		引数をSYSTIM型とみなし，10進数で表示
	%Tx		引数をSYSTIM型とみなし，16進数（英文字は小文字）で表示
	%TX		引数をSYSTIM型とみなし，16進数（英文字は大文字）で表示

ただし，引数をログ情報に出力する際には，LOGPAR型にキャストされる．その
ため，LOGPAR型（標準ではintptr_tに定義）より大きいサイズのデータは，正
しく表示されない．正しく表示したい場合には，ターゲット依存部でLOGPAR型
の定義を変更すれば良い．

%tu，%tx，%tXは，RELTIM型やTMO型の変数を表示するために使うことを想定し
た機能である．

・arg1～argnにポインタを渡す場合（%sに対応する引数の場合），ポインタの
の指すデータは，このマクロ処理を終えた後も変化してはならない．定数文字
列を渡すことを想定している．

(3) void syslog(uint_t prio, const char *format, ...)

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するための関数で，引
数の数を可変にしたもの．formatに続く引数は最大5個まで．formatおよびそれ
に続く引数には，syslog_nと同様の制限がある．

このライブラリ関数は，可変数引数を処理するために内部で文字列をスキャン
する．そのため，実行時間が長くなる可能性があり，割込み禁止状態で呼び出
すべきではない．主にアプリケーションプログラムが用いることを想定してい
る．

(4) UINT LOG_MASK(UINT prio)

重要度prioのみセットされたビットマップを作るマクロ．syslog_msk_logに渡
す引数を作るために用いる．

(5) UINT LOG_UPTO(UINT prio)

重要度prio以上の重要度がすべてセットされたビットマップを作るマクロ．
syslog_msk_logに渡す引数を作るために用いる．

8.1.8 システムログ機能のその他のサービス

システムログ機能は，前記のサービスコール等に加えて，初期化処理のための
関数を持つ．

(1) void syslog_initialize(intptr_t exinf)

システムログ機能を初期化する．ログバッファにログ情報が記録されている場
合には，消去される．syslog.cfgによって，カーネルに初期化ルーチンとして
登録される．exinfは無視される．

8.2 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルポートを扱うためのドライバで
ある．

シリアルインタフェースドライバは，システムコンフィギュレーションファイ
ルでserial.cfgをインクルードすることで，システムに組み込むことができる．
シリアルインタフェースドライバを呼び出すソースファイルでは，serial.hを
インクルードする．

シリアルインタフェースドライバは，ポート毎にセマフォを2個ずつ使用する．
セマフォを生成する静的APIは，serial.cfgに含まれている．

8.2.1 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は次の通り
である．この中で，シリアルポートのID番号（portid）の解釈はターゲット依
存となる．

これらのサービスコールは，非タスクコンテキストから呼び出すことはできな
い．また，serial_rea_datとserial_wri_datは，ディスパッチ保留状態で呼び
出すことはできない．いずれも，呼び出した場合にはE_CTXエラーとなる．

(1) ER serial_opn_por(ID portid)

portidで指定されたシリアルポートをオープンし，受信／送信が可能な状態に
する．

(2) ER serial_cls_por(ID portid)

portidで指定されたシリアルポートをクローズする．

(3) ER_UINT serial_rea_dat(ID portid, char *buf, uint_t len)

portidで指定されたシリアルポートから，lenバイトの文字列を受信し，bufか
らの領域に入れる．lenバイト受信するまで，待ち状態となる．受信した文字数
またはエラーコードを返す．

(4) ER_UINT serial_wri_dat(ID portid, const char *buf, uint_t len)

portidで指定されたシリアルポートに，bufからのlenバイトの文字列を送信す
る．lenバイト送信バッファに入れるまで，待ち状態となる．送信した文字数ま
たはエラーコードを返す．

(5) ER serial_ctl_por(ID portid, uint_t ioctl)

portidで指定されたシリアルポートの制御情報を，ioctlで示される値に設定す
る．

ioctlには，以下の制御情報を表す定数を，ビット毎に論理和をとったものを
指定する．

	IOCTL_ECHO（エコーバックモード）
		このビットを設定すると，シリアルインタフェースドライバがエコー
		バックを行う．具体的には，バッファから文字を取り出す度に，その
		文字を書き出す．

	IOCTL_CRLF（改行モード）
		LF（line feed）を書き出すと，CR（carriage return）＋LFに変換し
		て書き出す．

	IOCTL_FCSND（送信フロー制御）
		文字を送信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，STOP（コントロール-S）を受信すると送信を停止し，
		START（コントロール-Q）を受信すると送信を再開する．

	IOCTL_FCANY（送信フロー制御で任意の文字で送信再開）
		IOCTL_FCSNDを指定している時に，送信停止中に受信した任意の文字
		で送信を再開する．

	IOCTL_FCRCV（受信フロー制御）
		文字を受信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，受信バッファの残り領域が少なくなるとSTOP（コントロー
		ル-S）を送出し，残り領域が増えればSTART（コントロール-Q）を送
		出する．

なお，オープン直後のデフォルトの設定値は(IOCTL_ECHO | IOCTL_CRLF |
IOCTL_FCSND | IOCTL_FCRCV)である．

(6) ER serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor)

portidで指定されたシリアルポートの状態を参照し，pk_rporで指定されるパケッ
トに返す．パケット中のreacntには受信バッファ中の文字数を，wricntには送
信バッファ中の文字数を返す．

8.2.2 シリアルインタフェースドライバのその他のサービス

シリアルインタフェースドライバは，前記のサービスコールに加えて，初期化
処理と未送信文字の取出し処理を持つ．初期化処理は，カーネルに初期化ルー
チンとして登録する．また，ターゲット依存で，初期化処理，終了処理，割込
みサービスルーチンを持つ．これらの登録処理はserial.cfgに含まれる．

(1) void serial_initialize(intptr_t exinf)

シリアルインタフェースドライバを初期化する．カーネルに初期化ルーチンと
して登録する．exinfは無視する．

(2) bool_t serial_get_chr(ID portid, char *p_c)

portidで指定されたシリアルポートの送信バッファ中の文字を，p_cの指す番地
に取り出し，trueを返す関数．文字がなかった時には，falseを返す．終了処理
ルーチン中で呼び出すことを想定している．

8.3 システムログタスク

システムログタスクは，システムログ機能からログ情報を取り出し，それをシ
ステムの外部に出力するためのサービスである．

ASP3カーネルの配布パッケージに含まれるシステムログタスクは，シリアルポー
トにログ情報を文字列の形で出力するもので，システムログタスクの一例とい
う位置付けで提供している．

このシステムログタスクは，システムコンフィギュレーションファイルで
logtask.cfgをインクルードすることで，システムに組み込むことができる．シ
ステムログタスクのサービスを呼び出すソースファイルでは，logtask.hをイン
クルードする．

システムログタスクが実行開始されると，重要度がLOG_EMERGのログ情報を低レ
ベル出力機能を用いて出力し，重要度がLOG_NOTICEかそれより高いログ情報を
ログバッファに記録するように，システムログ機能の設定が変更される．

8.3.1 システムログタスクのサービスコール

システムログタスクのサービスを呼び出すサービスコールの仕様は次の通りで
ある．

(1) ER logtask_flush(uint_t count)

システムログ機能のログバッファ中のログ情報の数がcount以下になるまで待つ．
countが0の場合には，シリアルインタフェースドライバの送信バッファが空に
なるのも待つ．

8.3.2 システムログタスクのその他のサービス

システムログタスクは，前記のサービスコールに加えて，メイン処理と終了処
理を持つ．メイン処理はタスクとして，終了処理は終了処理ルーチンとして登
録する．これらの登録処理はlogtask.cfgに含まれる．

(1) void logtask_main(intptr_t exinf)

システムログタスクのメイン処理．exinfには，ログ情報を出力するシリアルポー
トのID番号を渡す．

(2) void logtask_terminate(intptr_t exinf)

システムログタスクの終了処理．シリアルインタフェースドライバの送信バッ
ファに蓄積されたデータと，ログバッファに記録されたログ情報を，低レベル
出力機能を用いて出力する．出力すべきログ情報がある場合には，それを出力
する前に，"-- buffered messages --"という文字列を出力する．exinfは無視
する．

この関数を終了処理ルーチンとして登録することで，カーネル終了時点で未出
力のログ情報のほとんどを出力することができる．ただし，未出力のログ情報
の内，システムログタスクのメイン処理が，ログバッファから取り出したが，
まだシリアルインタフェースドライバに送信していない情報は，この関数では
出力できない．

8.4 実行時間分布集計サービス

実行時間分布集計サービスは，システムのリアルタイム性能を評価するために，
プログラム区間の実行時間を計測し，その分布を集計・表示するためのシステ
ムサービスである．

実行時間分布集計サービスを用いる場合には，histogram.hをインクルードし，
histogram.cをコンパイル・リンクする．

実行時間分布集計サービスは，複数のプログラム区間の実行時間を計測・集計・
表示することができる．プログラム区間毎に，実行時間分布を記録するための
データ構造を持つ．どのデータ構造を用いるかを，ID番号（histid）で指定す
る．使用できるデータ構造の数は，TNUM_HISTで定義される．すなわち，ID番号
として，1～TNUM_HISTを指定することができる．TNUM_HISTは，デフォルト値が
histgram.cの中で定義されており，コンパイルオプションやターゲット依存部
（target_test.hまたはそこからインクルードされるファイル）により変更する
ことができる．

ターゲット依存部で設定を変更していない場合，実行時間分布集計サービスは，
カーネルの高分解能タイマを参照する機能（fch_hrt）を用いて実行時間を計測
する．そのため，実行時間はマイクロ秒単位で記録される（精度はターゲット
依存）．また，記録される時間には，計測のためのオーバヘッド（fch_hrtの実
行時間＋α）が含まれる．

ターゲット依存部で設定を変更している場合の仕様については，ターゲット依
存部のユーザーズマニュアルを参照すること．

(1) void init_hist(ID histid, uint_t maxval, uint_t histarea[])

histidで指定されたデータ構造を初期化する．maxvalには記録する最大時間を，
histareaには記録領域の先頭番地を指定する．histareaで始まる記憶領域は，
要素数がmaxvalに指定した値+1のuint_t型の配列として確保する．例えば，
maxvalに1000を指定する場合には，histareaには要素数が1001のuint_t型の配
列の先頭番地を渡す．

(2) void begin_measure(ID histid)

実行時間を計測するプログラム区間の直前に呼び出す関数．histidで指定され
たデータ構造に，現在のシステム時刻を記録する．

(3) void end_measure(ID histid)

実行時間を計測するプログラム区間の直後に呼び出す関数．現在のシステム時
刻と，histidで指定されたデータ構造に記録された開始時刻から，プログラム
区間の実行時間を求め，その結果を記録する．

(4) void print_hist(ID histid, void (*flush)(void))

システムログ機能を用いて，実行時間分布の計測結果を出力する．ログバッファ
が溢れるのを防ぐために，計測結果の出力中および出力後に，flushで指定され
た関数を呼び出す．

8.5 カーネル起動メッセージの出力

カーネル起動メッセージの出力は，カーネルの起動時に，カーネルの名称やバー
ジョン番号，著作権表示などを出力するための機能である．

カーネル起動メッセージの出力は，システムコンフィギュレーションファイル
でbanner.cfgをインクルードすることで，システムに組み込むことができる．

カーネル起動メッセージの出力は，次の関数で構成される．

(1) void print_banner(intptr_t exinf)

システムログ機能を用いて，カーネル起動メッセージを出力する．banner.cfg
によって，カーネルに初期化ルーチンとして登録される．exinfは無視される．

１０．テストプログラム

テストプログラムは，カーネルの機能テストおよび性能評価を行うためのプロ
グラム群である．

10.1 テストプログラム用サービス

テストプログラム用サービスは，プログラム中のチェックポイントが正しい順
序で実行されたことなど，プログラムが正しく動作していることをチェックす
るためのシステムサービスである．プログラムが正しく動作していないことを
検出した場合には，プログラムを終了させる．

テストプログラム用サービスを用いる場合には，test_svc.hをインクルードし，
test_svc.cをコンパイル・リンクする．

(1) void test_start(char *progname)

テストプログラムの開始時に呼び出す関数．prognameには，テストプログラム
名を渡す．

(2) void set_bit_service(BIT_FUNC bit_service)

チェックポイントにおいて呼び出す自己診断関数を設定するための関数．

(3) void check_point(uint_t count)

チェックポイントを通過する際に呼び出す関数．countには，何番目のチェック
ポイントであるかを指定する（最初のチェックポイントでは1を指定する）．
countの値が，最初のチェックポイントにおいては1でない場合に，それ以降の
チェックポイントにおいては，前のチェックポイント通過時にcountに指定した
値に1を加えた値でない場合に，プログラムが正しく動作していないと見なし，
プログラムを終了させる．

(4) void check_finish(uint_t count)

最後のチェックポイントに到達した際に呼び出す関数．countには，何番目の
チェックポイントであるかを指定する（最初のチェックポイントでは1を指定す
る）．countの値が，前のチェックポイント通過時にcountに指定した値に1を加
えた値でない場合に，プログラムが正しく動作していないと見なす．この関数
は，プログラムが正しく動作している／いないに関わらず，プログラムを終了
させる．

チェックポイントを使用しないテストプログラムの場合には，countに0を指定
してこの関数を呼び出し，プログラムを終了させる．

(5) void check_assert(bool_t exp)

expが真であることをチェックしたい場合に呼び出す関数．expが偽である場合
に，プログラムが正しく動作していないと見なし，プログラムを終了させる．

(6) void check_ercd(ER ercd, ER expected_ercd)

ercdがexpected_ercdに一致していることをチェックしたい場合に呼び出す関数．
ercdがexpected_ercdに一致していない場合に，プログラムが正しく動作してい
ないと見なし，プログラムを終了させる．

(7) void check_state(bool_t ctx, bool_t loc,
						bool_t dsp, bool_t dpn, bool_t ter)

システム状態が期待したものになっているかチェックしたい時に呼び出す関数．
ctx，loc，dsp，dpn，terには，それぞれsns_ctx()，sns_loc()，sns_dsp()，
sns_dpn()，sns_ter()の返値として期待される値を指定する．この内のいずれ
かが期待される値と一致していない場合に，プログラムが正しく動作していな
いと見なし，プログラムを終了させる．

(8) void check_ipm(PRI ipm)

割込み優先度マスクが期待した値になっているかチェックしたい時に呼び出す
関数．ipmには，get_ipm()で参照できる割込み優先度マスクとして期待される
値を指定する．期待される値と一致していない場合に，プログラムが正しく動
作していないと見なし，プログラムを終了させる．

10.2 カーネルの整合性検査

チェックポイントにおいて呼び出す自己診断に使うためのプログラムとして，
カーネルの整合性検査を用意している．カーネルの整合性検査は，カーネル内
の各データ構造の一貫性を検査する（現時点では未完成）．

カーネルの整合性検査を用いる場合には，それぞれ，bit_kernel.c，
bit_mutex.cをコンパイル・リンクする．

(1) ER bit_kernel(void)

カーネル内の各データ構造の一貫性を検査し，一貫性が確認できた場合にE_OK，
できなかった場合にE_SYSエラーを返す関数．E_SYSエラーを返す際のサブエラー
コードとして，一貫性が確認できなかった項目を示すコードを返す．

(2) ER bit_mutex(void)

カーネル内のミューテックス関連のデータ構造の一貫性を検査し，一貫性が確
認できた場合にE_OK，できなかった場合にE_SYSエラーを返す関数．E_SYSエラー
を返す際のサブエラーコードとして，一貫性が確認できなかった項目を示すコー
ドを返す．

10.3 機能テストプログラム

testディレクトリに置かれた"test"で始まるプログラムは，カーネルの機能テ
ストを行うためのプログラムである．

機能テストプログラムはテストプログラム用サービスを使用しているため，構
築する場合には，MakefileのSYSSVC_COBJSに，test_svc.oを追加する必要があ
る．コンフィギュレーションスクリプトを使用する場合には，-Sオプションで
test_svc.oを指定する．具体的には，次のコマンドを実行すればよい（構築用
のディレクトリが，ASP3カーネルのソースファイルを展開したディレクトリの
直下にあると仮定している）．

	% ruby ../configure.rb -T <ターゲット略称> -A <テストプログラム名> \
											-a ../test -S test_svc.o

ただし，CPU例外処理のテスト(1)～(13)は，同一のシステムコンフィギュレー
ションを共用しているため，test_cpuexc.cfgを次のようにコピーしておく必要
がある．

	% cp ../test/test_cpuexc.cfg test_cpuexc<テスト番号>.cfg

また，いくつかのテストプログラムでは，カーネルの整合性検査を実施してい
る．該当するテストプログラムを構築する場合には，MakefileのSYSSVC_COBJS
に，bit_kernel.oまたはbit_mutex.oを追加する必要がある．コンフィギュレー
ションスクリプトを使用する場合には，-Sオプションでこれらのファイルを指
定する．具体的には，次のコマンドを実行すればよい．

	% ruby ../configure.rb -T <ターゲット略称> -A <テストプログラム名> \
				-a ../test -S "test_svc.o bit_kernel.o bit_mutex.o"

現バージョンで用意している機能テストプログラムは次の通り．

(1) test_cpuexc1			CPU例外処理のテスト(1)
(2) test_cpuexc2			CPU例外処理のテスト(2)
(3) test_cpuexc3			CPU例外処理のテスト(3)
(4) test_cpuexc4			CPU例外処理のテスト(4)
(5) test_cpuexc5			CPU例外処理のテスト(5)
(6) test_cpuexc6			CPU例外処理のテスト(6)
(7) test_cpuexc7			CPU例外処理のテスト(7)
(8) test_cpuexc8			CPU例外処理のテスト(8)
(9) test_cpuexc9			CPU例外処理のテスト(9)
(10) test_cpuexc10			CPU例外処理のテスト(10)
(11) test_dlynse			sil_dly_nseに関するテスト
(12) test_flg1				イベントフラグ機能のテスト(1)
(13) test_dtq1				データキュー機能のテスト(1)
(14) test_hrt1.c			fch_hrtに関するテスト(1)
(15) test_int1.c			割込み管理機能のテスト(1)
(16) test_mutex1.c			ミューテックス機能のテスト(1)
(17) test_mutex2.c			ミューテックス機能のテスト(2)
(18) test_mutex3.c			ミューテックス機能のテスト(3)
(19) test_mutex4.c			ミューテックス機能のテスト(4)
(20) test_mutex5.c			ミューテックス機能のテスト(5)
(21) test_mutex6.c			ミューテックス機能のテスト(6)
(22) test_mutex7.c			ミューテックス機能のテスト(7)
(23) test_mutex8.c			ミューテックス機能のテスト(8)
(24) test_notify1.c			通知処理のテスト(1)
(25) test_raster1.c			タスク終了要求機能に関するテスト(1)
(26) test_raster2.c			タスク終了要求機能に関するテスト(2)
(27) test_sem1				セマフォ機能のテスト(1)
(28) test_sem2				セマフォ機能のテスト(2)
(29) test_sysman1			システム状態管理機能のテスト(1)
(30) test_sysstat1			システム状態に関するテスト(1)
(31) test_task1				タスク管理モジュールのテスト(1)
(32) test_tmevt1.c			タイムイベント管理モジュールのテスト(1)

CPU例外処理のテストプログラムの一部は，CPU例外ハンドラからリターンした
場合に，CPU例外を発生させた命令の次から実行が継続されることを前提に作成
されている．この前提が成り立たない場合には，テストプログラムのターゲッ
ト依存定義において，PREPARE_RETURN_CPUEXCの定義で対応することが必要であ
る．詳しくは，「ターゲット依存部 ポーティングガイド」を参照すること．

10.4 システム時刻管理機能テストプログラム

testディレクトリに置かれた"hrt"で始まるプログラムは，高分解能タイマを用
いて実現したシステム時刻管理機能に関するテストを行うためのプログラムで
ある．

システム時刻管理機能テストプログラムは，テストデータに駆動されて動作す
るテスト用の高分解能タイマモジュールを必要とする．そのため，テスト用の
高分解能タイマモジュールを組み込んだターゲット依存部を用いてテストを行
わなければならない．

テスト用の高分解能タイマモジュールを用いたカーネルをコンパイルする際に
は，高分解能タイマモジュールの性質を切り換えるためのマクロ定義が必要で
ある．具体的には，-DHRT_CONFIG1または-DHRT_CONFIG2のいずれかのコンパイ
ルオプションをつける必要がある．どちらのコンパイルオプションを付けるべ
きかは，テストプログラム毎に決まっている．

また，システム時刻管理機能テストプログラムは，機能テストプログラムと同
様に，テストプログラム用サービスを使用している．

以上より，システム時刻管理機能テストプログラムをコンフィギュレーション
スクリプトを使用して構築する場合には，次のコマンドを実行すればよい（構
築用のディレクトリが，ASP3カーネルのソースファイルを展開したディレクト
リの直下にあると仮定している）．

	% ruby ../configure.rb -T <テスト用のターゲット略称> \
				 -A <テストプログラム名> -a ../test -S test_svc.o \
				-O -DHRT_CONFIG<1または2>

現バージョンで用意しているシステム時刻管理機能テストプログラムは次の通
り．

(1) hrt_systim1				システム時刻管理機能のテスト(1)
(2) hrt_systim2				システム時刻管理機能のテスト(2)
(3) hrt_systim3				システム時刻管理機能のテスト(3)
(4) hrt_systim4				システム時刻管理機能のテスト(4)

この内，hrt_systim4は-DHRT_CONFIG2をつけて，他は-DHRT_CONFIG1をつけてコ
ンパイルすること．

10.5 性能評価プログラム

testディレクトリに置かれた"perf"で始まるプログラムは，カーネルの性能評
価を行うためのプログラムである．

性能評価プログラムは，計測対象となる処理を繰り返し実行し，その実行時間
を計測して，実行時間分布を表示する．

計測した実行時間には，時間計測のオーバヘッド（時間計測処理の実行にかか
る時間）が含まれる．計測対象の処理の正味の実行時間を求めるためには，計
測された時間から，時間計測のオーバヘッドを計測するためのプログラム
（perf0）で計測された時間を減算する必要がある．

また，実行時間の計測は，別に記述がない限り割込みを許可したまま行うため，
割込みハンドラ（少なくとも，タイマ割込みハンドラ）の処理時間が含まれた
実行結果が計測される．

カーネルの性能評価にあたっては，ハードウェア（特にキャッシュ）の設定に
留意する必要がある．

性能評価プログラムはテストプログラム用サービスと実行時間分布集計サービ
スを使用しているため，構築する場合には，MakefileのSYSSVC_COBJSに，
test_svc.oとhistogram.oを追加する必要がある．コンフィギュレーションスク
リプトを使用する場合には，-Sオプションでtest_svc.oとhistgram.oを指定す
る．具体的には，次のコマンドを実行すればよい（構築用のディレクトリが，
ASP3カーネルのソースファイルを展開したディレクトリの直下にあると仮定し
ている）．

	% ruby ../configure.rb -T <ターゲット略称> -A <性能評価プログラム名> \
									-a ../test -S "test_svc.o histogram.o"

現バージョンで用意している性能評価プログラムは次の通り．

(1) perf0		時間計測のオーバヘッドの評価

時間計測のオーバヘッドを計測するためのプログラム．具体的には，空のプロ
グラム（begin_mearsureとend_measureを続けて呼び出すプログラム）の実行時
間を計測する．

他の性能評価プログラムで計測された時間から，このプログラムで計測された
時間を減算した時間が，計測対象の処理の正味の実行時間である．

(2) perf1		slp_tsk，wup_tskによるタスク切換え時間の評価

slp_tsk，wup_tskによるタスク切換え時間を計測するためのプログラム．具体
的には，高い優先度のタスクが起床待ち状態である時に，低い優先度のタスク
がwup_tskにより高い優先度のタスクを起床し，高い優先度のタスクに切り換わ
るまでの時間と，高い優先度のタスクがslp_tskにより起床待ち状態となり，低
い優先度のタスクに切り換わるまでの時間を計測する．

(3) perf2		snd_pdqの処理時間の評価

優先度データキューに蓄積されているデータの数により，snd_pdqの処理時間が
どのように変化するかを計測するためのプログラム．具体的には，優先度デー
タキュー中に高い優先度のデータがn個蓄積されている時に，snd_dtqにより低
い優先度のデータを入れるのにかかる時間を計測する．nを0，10，20，30，40，
50，100，200，300と変化させて計測する．

(4) perf3		set_flgの処理時間の評価

待ち解除するタスクの数により，set_flgの処理時間がどのように変化するかを
計測するためのプログラム．具体的には，TA_WMUL属性のイベントフラグに対し
て，n個のタスクが待っている時に，set_flgによりそのすべてを待ち解除する
のにかかる時間を計測する．nを0，1，2，3，4，5，10，20と変化させて計測す
る．

(5) perf4		act_tskの処理時間とタスク切換え時間の評価

act_tskの処理時間とタスク切換え時間を計測するためのプログラム．具体的に
は，(1) タスクコンテキストから呼び出し，タスク切換えを起こさない
act_tskの処理時間，(2) タスクコンテキストから呼び出し，タスク切換えを起
こすact_tskの処理時間（タスク切換え時間を含む），(3) 非タスクコンテキス
トから呼び出し，タスク切換えを起こすact_tskの処理時間（タスク切換え時間
とタイマ割込み中で実行されるシステム時刻の更新処理時間を含む）の3つの時
間を計測する．

(6) perf5		タイムイベント処理時間の評価

タイムイベントヒープ操作のオーバヘッドにより，sta_alm，stp_almの処理時
間がどのように変化するかを計測するためのプログラム．具体的には，タイム
イベントヒープ中でのノードの交換回数が，ない場合，少ない場合，多い場合
で，sta_almとstp_almの処理時間を計測する．

13.3 バージョン履歴

	2017年7月04日	Release	3.1.0
	2017年7月28日	Release	3.2.0

以上
